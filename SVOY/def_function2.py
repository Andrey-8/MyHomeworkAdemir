'''Объявление и вызов функций
Объявим функцию:'''
from modul_2.module_2_3 import my_list


def hello():
    print('Adele is cute')
# После того как мы это сделали, функцию можно вызвать в любой части программы,
# но ниже самого объявления.
hello()

"""Область видимости функций"""

#Локальная область видимости находится внутри def:
def L():
    # переменная i_am_local является локальной внутри L()
    i_am_local = 5

"""Область объемлющих функций (E)"""
#Объявили функцию e(). Внутри неё объявили функцию inner_e().
# Относительно inner_e() все переменные, объявленные в e() будут относиться
# к области объемлющих функций. Такие переменные являются нелокальными
# в inner_e(). Чтобы с ними взаимодействовать, нужно использовать ключевое
# слово nonlocal:
def e():
    x = 5
    def inner_e():
        nonlocal x
        x = x + 1
        return x
    return inner_e()
print(e())
# выход = 6

"""Глобальная (G)"""
# Глобальная область видимости лежит за пределами всех def
# G
num = 42
def some_function(n):
    res = n + num
    return res
print(some_function(1))
# выход = 43

"""Аргументы"""

# Позиционные
# аргумент — это конкретное значение, которое передаётся в функцию.
# Аргументом может быть любой объект. Он может передаваться, как
# в литеральной форме, так и в виде переменной.

# Значения в позиционных аргументах подставляются согласно позиции имён аргументов:

nums = [42, 11, 121, 13, 7]
state = True
# в данном примере
#    1-я позиция "nums" -> parameter_1
#    2-я позиция "state" -> parameter_2
def test_params(parameter_1, parameter_2):
    pass
# равнозначные варианты вызова функции
# или так
test_params(nums, state)
# или так
test_params([42, 11, 121, 13, 7], True)

"""Именованные"""
# При вызове соответствие будет определяться по именам, а не по позициям аргументов.
def print_trio(a, b, c):
    print(a, b, c)
print_trio(c=4, b=5, a=6) # выход = 6 5 4

"""Необязательные параметры (параметры по умолчанию)"""
def not_necessary_arg(x='My', y='love'):
    print(x, y)
# если не передавать в функцию никаких значений, она отработает
# со значениями по умолчанию
not_necessary_arg() # выход = My love
# переданные значения заменяют собой значения по умолчанию
not_necessary_arg(2, 1) # выход = 2 1

'''Аргументы переменной длины (args, kwargs)'''
# Когда заранее неизвестно, сколько конкретно аргументов будет передано
# в функцию, мы пользуемся аргументами переменной длины.
# Звёздочка "*" перед именем параметра сообщает интерпретатору о том,
# что количество позиционных аргументов будет переменным:
def infinity(*args):
    print(args)

infinity(42, 12, 'test', [6, 5])
# Переменная args составляет кортеж из переданных в функцию аргументов.
# выход = (42, 12, 'test', [6, 5])

# Функции в питоне могут также принимать и переменное количество
# именованных аргументов. В этом случае перед названием параметра ставится "**":
def named_infinity(**kwargs):
    print(kwargs)
# Здесь kwargs уже заключает аргументы не в кортеж, а в словарь.
named_infinity(first='nothing', second='else', third='matters')
# на выходе = {'first': 'nothing', 'second': 'else', 'third': 'matters'}

'''Передача переменных в функцию по значению и по ссылке'''
num = 120
my_list = [1, 2]
def test(a, b):
    a = b
# Передача аргументов в функцию по значению (num) и по ссылке (my_list)
test(num, my_list)

# Если объект неизменяемый, то он передаётся в функцию по значению.
# Неизменяемые объекты это:
# Числовые типы (int, float, complex).
# Строки (str).
# Кортежи (tuple).
num = 42
def some_function(n):
    # в "n" передается значение переменной num (42)
    n = n + 10
    print(n)
some_function(num)
print(num)  # "num" по прежнему содержит 42
# на выходе
# 52
# 42

# Изменяемые объекты передаются в функцию по ссылке.
# Изменяемыми они называются потому что их содержимое можно менять,
# при этом ссылка на сам объект остается неизменной.
# В Python изменяемые объекты это:
# Списки (list).
# Множества (set).
# Словари (dict).
num = [42, 43, 44]
def some_function(n):
    # в "n" передается ссылка на переменную "num".
    # "n" и "num" ссылаются на один и тот же объект
    n[0] = 0
    print(n)

some_function(num)
print(num)  # "num" изменился
# на выходе
# [0, 43, 44]
# [0, 43, 44]