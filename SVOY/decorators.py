"""ДЕКОРАТОРЫ - функция, оборачивающая другую функцию в свой код, изменяя ее поведение"""

# функция для примера def make():
# когда большой проект, с сотнями функций, возникают ошибки или надо просто как-то изменить
# поведение этих функций, но функции вклинины в код, жестко под своим именем (например вызов
# данной функции - make(). Постоянно временно переписывать, при необходимости коды в этих функциях -
# затруднительно, но необхолдимо. Для этого и существуют декораторы

# создадим функцию декоратор, назовем ее decor, она будет принимать функцию make(), как аргумент, т.е.
# дадим ей параметр (ну пусть будет просто f)
# для декораторов, сущ. спец. синтаксис - @decor ((@ и имя декоратора))
# эта запись - @decor, будет значить, что имя декорируемой функции, становится равной функции декоратору
# decor(), в которой аргументом будет имя декорируемой функции: decor(make)


def decor(f):
    def wrapper():  # стандартное название для такой функции - обертки
        # тут прописывается какой-то код, который как-то изменяет поведение декорируемой функции
        print("код декоратора")
        f()  # тут уже через параметр f, будет вызываться функция make
        print("Второй код декоратора")

    return wrapper
    # после такого return, происходит следующее, в строке кода @decor,
    # запускается функция decor(f) куда передается имя make (параметр f принимает имя make),
    # тогда запускается выполнение функции decor(f), она возвращает имя вложенной функции
    # wrapper, тогда make становится равен wrapper и уже тогда, можно указать первоначальный
    # вызов функции make, как make(), для запуска выполнения функции


@decor
def make():
    enter = input("введите что-нибудь: ")
    print(enter)


make()

# внутри функции декоратора, создаем вложенную функцию (обертку) wrapper (стр.17)
# и возвращаем из функции декоратора (decor),  имя вложенной функции wrapper
# по итогу, декоратор позволяет модифицировать действия функции, не вмешиваясь в ее код
