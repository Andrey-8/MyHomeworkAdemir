class FRange:
    
    # В ИНИЦИАЛИЗАТОРЕ, ПРОПИСЫВАЕМ ЛОКАЛЬНЫЕ СВОЙСТВА СТАРТ, СТОП, СТЕП,, НУЖНЫЕ ДЛЯ
    # ГЕНЕРАЦИИ АРИФМЕТИЧЕСКОЙ ПОСЛЕДОВАТЕЛЬНОСТИ
    def __init__(self, start=0.0, stop=0.0, step=1.0):
        self.start = start
        self.stop = stop
        self.step = step
        
        
    # ЧТО БЫ fr СТАЛ ИТЕРРИРУЕМЫМ ОБЪЕКТОМ, ИСПОЛЬЗУЕМ МЕТОД __iter__
    def __iter__(self):
        # ОПРЕДЕЛЯЕМ ТЕКУЩЕЕ ЗНАЧЕНИЕ:
        self.value = self.start - self.step
        
        # просто возвращаем экземпляр класса, т.к. итератором будем делать fr.
        return self
        
    # ДЛЯ ПОЛУЧЕНИЯ ТЕКУЩЕГО ЗНАЧЕНИЯ АРИФМЕТИЧЕСКОЙ ПОСЛЕДОВАТЕЛЬНОСТИ
    def __next__(self):
        # self.value - ТЕКУЩЕЕ ЗНАЧЕНИЕ АРИФМЕТИЧЕСКОЙ ПОСЛЕДОВАТЕЛЬНОСТИ
        # ЕСЛИ ТЕКУЩЕЕ ЗНАЧЕНИЕ (self.value) + ШАГ < КОНЕЧНОГО ЗНАЧЕНИЯ
        if self.value + self.step < self.stop:
            
        # ТОГДА УВЕЛИЧИВАЕМ ТЕКУЩЕЕ ЗНАЧЕНИЕ НА ВЕЛИЧИНУ ШАГА
            self.value += self.step
            
        # ПОСЛЕ ЧЕГО ВОЗВРАЩАЕМ ТЕКУЩЕЕ (ИЗМЕНИВШЕЕСЯ) ЗНАЧЕНИЕ
            return self.value
        
        # ИНАЧЕ ГЕНЕРИРУЕМ ИСКЛЮЧЕНИЕ СТОП ИТЕРАЦИЯ
        else:
            raise StopIteration ('ОСТАНОВКА ПЕРЕБОРА')
        

# СОЗДАДИМ ЭКЗЕМПЛЯР КЛАССА
fr = FRange(0, 2, 0.5)

# после создания маг.метода __iter__, можно использовать цикл for
for x in fr:
    print(x)

# вызываем 4 раза метод __next__
#print(next(fr))  # в роли итератора, выступает ЭКЗЕМПЛЯР КЛАССА fr
#print(next(fr))
#print(next(fr))
#print(next(fr))
